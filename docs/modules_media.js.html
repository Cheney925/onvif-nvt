<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: modules/media.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: modules/media.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Soap = require('../utils/soap')
const Util = require('../utils/util')

/**
 * @class Media
 * &lt;p>
 * {@link https://www.onvif.org/specs/srv/media/ONVIF-Media-Service-Spec-v1706.pdf}&lt;br>
 * {@link https://www.onvif.org/ver10/media/wsdl/media.wsdl}&lt;br>
 * &lt;/p>
 * &lt;h3>Functions&lt;/h3>
 * {@link Media#createProfile},
 * {@link Media#getProfiles},
 * {@link Media#getProfile},
 * {@link Media#addVideoSourceConfiguration},
 * {@link Media#addVideoEncoderConfiguration},
 * {@link Media#addAudioSourceConfiguration},
 * {@link Media#addAudioEncoderConfiguration},
 * {@link Media#addPTZConfiguration},
 * {@link Media#addVideoAnalyticsConfiguration},
 * {@link Media#addMetadataConfiguration},
 * {@link Media#addAudioOutputConfiguration},
 * {@link Media#addAudioDecoderConfiguration},
 * removeVideoSourceConfiguration,
 * removeVideoEncoderConfiguration,
 * removeAudioSourceConfiguration,
 * removeAudioEncoderConfiguration,
 * removePTZConfiguration,
 * removeVideoAnalyticsConfiguration,
 * removeMetadataConfiguration,
 * removeAudioOutputConfiguration,
 * removeAudioDecoderConfiguration,
 * {@link Media#deleteProfile},
 * {@link Media#getVideoSources},
 * {@link Media#getVideoSourceConfigurations},
 * {@link Media#getVideoSourceConfiguration},
 * {@link Media#getCompatibleVideoSourceConfigurations},
 * {@link Media#getVideoSourceConfigurationOptions},
 * setVideoSourceConfiguration,
 * {@link Media#getVideoEncoderConfigurations},
 * {@link Media#getVideoEncoderConfiguration},
 * {@link Media#getCompatibleVideoEncoderConfigurations},
 * {@link Media#getVideoEncoderConfigurationOptions},
 * setVideoEncoderConfiguration,
 * {@link Media#getGuaranteedNumberOfVideoEncoderInstances},
 * {@link Media#getAudioSources},
 * {@link Media#getAudioSourceConfigurations},
 * {@link Media#getAudioSourceConfiguration},
 * {@link Media#getCompatibleAudioSourceConfigurations},
 * {@link Media#getAudioSourceConfigurationOptions},
 * setAudioSourceConfiguration,
 * {@link Media#getAudioEncoderConfigurations},
 * {@link Media#getAudioEncoderConfiguration},
 * {@link Media#getCompatibleAudioEncoderConfigurations},
 * {@link Media#getAudioEncoderConfigurationOptions},
 * setAudioEncoderConfiguration,
 * {@link Media#getVideoAnalyticsConfigurations},
 * getVideoAnalyticsConfiguration,
 * getCompatibleVideoAnalyticsConfigurations,
 * setVideoAnalyticsConfiguration,
 * {@link Media#getMetadataConfigurations},
 * {@link Media#getMetadataConfiguration},
 * {@link Media#getCompatibleMetadataConfigurations},
 * {@link Media#getMetadataConfigurationOptions},
 * setMetadataConfiguration,
 * {@link Media#getAudioOutputs},
 * {@link Media#getAudioOutputConfigurations},
 * getAudioOutputConfiguration,
 * getCompatibleAudioOutputConfigurations,
 * getAudioOutputConfigurationOptions,
 * setAudioOutputConfiguration,
 * {@link Media#getAudioDecoderConfigurations},
 * getAudioDecoderConfiguration,
 * getCompatibleAudioDecoderConfigurations,
 * getAudioDecoderConfigurationOptions,
 * setAudioDecoderConfiguration,
 * {@link Media#getStreamUri},
 * {@link Media#getSnapshotUri},
 * {@link Media#startMulticastStreaming},
 * {@link Media#stopMulticastStreaming},
 * setSynchronizationPoint,
 * getVideoSourceModes,
 * setVideoSourceMode,
 * createOSD,
 * deleteOSD,
 * getOSDs,
 * getOSD,
 * setOSD,
 * getOSDOptions
 * &lt;br>&lt;br>
 * &lt;h3>Overview&lt;/h3>
 */
class Media {
  constructor () {
    this.timeDiff = 0
    this.serviceAddress = null
    this.username = null
    this.password = null

    this.namespaceAttributes = [
      'xmlns:env="http://www.w3.org/2003/05/soap-envelope "',
      'xmlns:ter="http://www.onvif.org/ver10/error"',
      'xmlns:xs="http://www.w3.org/2001/XMLSchema"',
      'xmlns:tt="http://www.onvif.org/ver10/schema"',
      'xmlns:trt="http://www.onvif.org/ver10/media/wsdl"'
    ]
  }

  /**
   * Call this function directly after instantiating a Media object.
   * @param {number} timeDiff The onvif device's time difference.
   * @param {object} serviceAddress An url object from url package - require('url').
   * @param {string=} username Optional only if the device does NOT have a user.
   * @param {string=} password Optional only if the device does NOT have a password.
   */
  init (timeDiff, serviceAddress, username, password) {
    this.timeDiff = timeDiff
    this.serviceAddress = serviceAddress
    this.username = username
    this.password = password
  }

  /**
   * Private function for creating a SOAP request.
   * @param {string} body The body of the xml.
   */
  createRequest (body) {
    let soapEnvelope = Soap.createRequest({
      'body': body,
      'xmlns': this.namespaceAttributes,
      'diff': this.timeDiff,
      'username': this.username,
      'password': this.password
    })
    return soapEnvelope
  };

  buildRequest (methodName, xml, callback) {
    let promise = new Promise((resolve, reject) => {
      let soapBody = ''
      if (typeof xml === 'undefined' || xml === null) {
        soapBody += `&lt;trt:${methodName}/>`
      }
      else {
        soapBody += `&lt;trt:${methodName}>`
        soapBody += xml
        soapBody += `&lt;/trt:${methodName}>`
      }
      let soapEnvelope = this.createRequest(soapBody)
      return Soap.makeRequest(this.serviceAddress, methodName, soapEnvelope)
        .then(results => {
          resolve(results)
        }).catch(error => {
          reject(error)
        })
    })
    if (callback) {
      promise.then(results => {
        callback(null, results)
      }).catch(error => {
        callback(error)
      })
    }
    else {
      return promise
    }
  }

  requestWithProfileToken (methodName, profileToken, callback) {
    let promise = new Promise((resolve, reject) => {
      let errMsg = ''
      if ((errMsg = Util.isInvalidValue(profileToken, 'string'))) {
        reject(new Error(`The "profileToken" argument for ${methodName} is invalid: ` + errMsg))
        return
      }

      let soapBody = ''
      soapBody += '&lt;trt:ProfileToken>' + profileToken + '&lt;/trt:ProfileToken>'

      this.buildRequest(methodName, soapBody)
        .then(results => {
          resolve(results)
        }).catch(error => {
          reject(error)
        })
    })
    if (callback) {
      promise.then(results => {
        callback(null, results)
      }).catch(error => {
        callback(error)
      })
    }
    else {
      return promise
    }
  }

  requestWithConfigurationToken (methodName, configurationToken, callback) {
    let promise = new Promise((resolve, reject) => {
      let errMsg = ''
      if ((errMsg = Util.isInvalidValue(configurationToken, 'string'))) {
        reject(new Error(`The "configurationToken" argument for ${methodName} is invalid: ` + errMsg))
        return
      }

      let soapBody = ''
      soapBody += '&lt;trt:ConfigurationToken>' + configurationToken + '&lt;/trt:ConfigurationToken>'

      this.buildRequest(methodName, soapBody)
        .then(results => {
          resolve(results)
        }).catch(error => {
          reject(error)
        })
    })
    if (callback) {
      promise.then(results => {
        callback(null, results)
      }).catch(error => {
        callback(error)
      })
    }
    else {
      return promise
    }
  }

  requestWithOptionalTokens (methodName, profileToken, configurationToken, callback) {
    let promise = new Promise((resolve, reject) => {
      let errMsg = ''
      if (typeof profileToken !== 'undefined' &amp;&amp; profileToken !== null) {
        if ((errMsg = Util.isInvalidValue(profileToken, 'string'))) {
          reject(new Error(`The "profileToken" argument for ${methodName} is invalid: ` + errMsg))
          return
        }
      }
      if (typeof configurationToken !== 'undefined' &amp;&amp; configurationToken !== null) {
        if ((errMsg = Util.isInvalidValue(configurationToken, 'string'))) {
          reject(new Error(`The "ConfigurationToken" argument for ${methodName} is invalid: ` + errMsg))
          return
        }
      }

      let soapBody = ''
      if (typeof profileToken !== 'undefined' &amp;&amp; profileToken !== null) {
        soapBody += '&lt;trt:ProfileToken>' + profileToken + '&lt;/trt:ProfileToken>'
      }
      if (typeof configurationToken !== 'undefined' &amp;&amp; configurationToken !== null) {
        soapBody += '&lt;trt:ConfigurationToken>' + configurationToken + '&lt;/trt:ConfigurationToken>'
      }

      this.buildRequest(methodName, soapBody)
        .then(results => {
          resolve(results)
        }).catch(error => {
          reject(error)
        })
    })
    if (callback) {
      promise.then(results => {
        callback(null, results)
      }).catch(error => {
        callback(error)
      })
    }
    else {
      return promise
    }
  }

  addConfiguration (methodName, profileToken, configurationToken, callback) {
    let promise = new Promise((resolve, reject) => {
      let errMsg = ''
      if ((errMsg = Util.isInvalidValue(profileToken, 'string'))) {
        reject(new Error(`The "profileToken" argument for ${methodName} is invalid: ` + errMsg))
        return
      }

      if ((errMsg = Util.isInvalidValue(configurationToken, 'string'))) {
        reject(new Error(`The "ConfigurationToken" argument for ${methodName} is invalid: ` + errMsg))
        return
      }

      let soapBody = ''
      soapBody += '&lt;trt:ProfileToken>' + profileToken + '&lt;/trt:ProfileToken>'
      soapBody += '&lt;trt:ConfigurationToken>' + configurationToken + '&lt;/trt:ConfigurationToken>'

      this.buildRequest(methodName, soapBody)
        .then(results => {
          resolve(results)
        }).catch(error => {
          reject(error)
        })
    })
    if (callback) {
      promise.then(results => {
        callback(null, results)
      }).catch(error => {
        callback(error)
      })
    }
    else {
      return promise
    }
  }

  // ---------------------------------------------
  // Media API
  // ---------------------------------------------

  /**
   * This operation creates a new empty media profile. The media profile shall be created in the device and shall be persistent (remain after reboot). A created profile shall be deletable and a device shall set the “fixed” attribute to false in the returned Profile.
   * @param {string} name friendly name of the profile to be created.
   * @param {string=} token Optional token, specifying the unique identifier of the new profile.&lt;br>
   * A device supports at least a token length of 12 characters and characters "A-Z" | "a-z" | "0-9" | "-.".
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  createProfile (name, token, callback) {
    let promise = new Promise((resolve, reject) => {
      let errMsg = ''
      if ((errMsg = Util.isInvalidValue(name, 'string'))) {
        reject(new Error('The "name" argument for createProfile is invalid: ' + errMsg))
        return
      }
      if (typeof token !== 'undefined' &amp;&amp; token !== null) {
        if ((errMsg = Util.isInvalidValue(token, 'string'))) {
          reject(new Error('The "token" argument for createProfile is invalid: ' + errMsg))
          return
        }
      }

      let soapBody = ''
      soapBody += '&lt;trt:Name>' + name + '&lt;/trt:Name>'
      if (typeof token !== 'undefined' &amp;&amp; token !== null) {
        soapBody += '&lt;trt:Token>' + token + '&lt;/trt:Token>'
      }

      this.buildRequest('CreateProfile', soapBody)
        .then(results => {
          resolve(results)
        }).catch(error => {
          reject(error)
        })
    })
    if (callback) {
      promise.then((result) => {
        callback(null, result)
      }).catch((error) => {
        callback(error)
      })
    }
    else {
      return promise
    }
  }

  /**
   * Any endpoint can ask for the existing media profiles of a device using the GetProfiles
   * command. Pre-configured or dynamically configured profiles can be retrieved using this
   * command. This command lists all configured profiles in a device. The client does not need to
   * know the media profile in order to use the command. The device shall support the retrieval of
   * media profiles through the GetProfiles command.&lt;br>
   * A device shall include the “fixed” attribute in all the returned Profile elements.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getProfiles (callback) {
    return this.buildRequest('GetProfiles', null, callback)
  }

  /**
   * If the profile token is already known, a profile can be fetched through the GetProfile command.
   * The device shall support the retrieval of a specific media profile through the GetProfile
   * command.&lt;br>
   * A device shall include the “fixed” attribute in the returned Profile element.
   * @param {string} profileToken this command requests a specific profile
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getProfile (profileToken, callback) {
    return this.requestWithProfileToken('GetProfile', profileToken, callback)
  }

  /**
   * This operation adds a VideoSourceConfiguration to an existing media profile. If such a
   * configuration exists in the media profile, it will be replaced. The change shall be persistent.&lt;br>
   * The device shall support addition of a video source configuration to a profile through the
   * AddVideoSourceConfiguration command.
   * @param {string} profileToken Reference to the profile where the configuration should be added
   * @param {string} configurationToken Contains a reference to the VideoSourceConfiguration to add
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  addVideoSourceConfiguration (profileToken, configurationToken, callback) {
    return this.addConfiguration('AddVideoSourceConfiguration', profileToken, configurationToken, callback)
  }

  /**
   * This operation adds a VideoEncoderConfiguration to an existing media profile. If a configuration exists in the media profile, it will be replaced. The change shall be persistent. A device shall support adding a compatible VideoEncoderConfiguration to a Profile containing a VideoSourceConfiguration and shall support streaming video data of such a profile.
   * @param {string} profileToken Reference to the profile where the configuration should be added
   * @param {string} configurationToken Contains a reference to the VideoEncoderConfiguration to add
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  addVideoEncoderConfiguration (profileToken, configurationToken, callback) {
    return this.addConfiguration('AddVideoEncoderConfiguration', profileToken, configurationToken, callback)
  }

  /**
   * This operation adds an AudioSourceConfiguration to an existing media profile. If a configuration exists in the media profile, it will be replaced. The change shall be persistent.
   * @param {string} profileToken Reference to the profile where the configuration should be added
   * @param {string} configurationToken Contains a reference to the AudioSourceConfiguration to add
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  addAudioSourceConfiguration (profileToken, configurationToken, callback) {
    return this.addConfiguration('AddAudioSourceConfiguration', profileToken, configurationToken, callback)
  }

  /**
   * This operation adds an AudioEncoderConfiguration to an existing media profile. If a configuration exists in the media profile, it will be replaced. The change shall be persistent. A device shall support adding a compatible AudioEncoderConfiguration to a profile containing an AudioSourceConfiguration and shall support streaming audio data of such a profile.
   * @param {string} profileToken Reference to the profile where the configuration should be added.
   * @param {string} configurationToken Contains a reference to the AudioEncoderConfiguration to add.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  addAudioEncoderConfiguration (profileToken, configurationToken, callback) {
    return this.addConfiguration('AddAudioEncoderConfiguration', profileToken, configurationToken, callback)
  }

  /**
   * This operation adds a PTZConfiguration to an existing media profile. If a configuration exists in the media profile, it will be replaced. The change shall be persistent. Adding a PTZConfiguration to a media profile means that streams using that media profile can contain PTZ status (in the metadata), and that the media profile can be used for controlling PTZ movement.
   * @param {string} profileToken Reference to the profile where the configuration should be added.
   * @param {string} configurationToken Contains a reference to the PTZConfiguration to add.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  addPTZConfiguration (profileToken, configurationToken, callback) {
    return this.addConfiguration('AddPTZConfiguration', profileToken, configurationToken, callback)
  }

  /**
   * This operation adds a VideoAnalytics configuration to an existing media profile. If a configuration exists in the media profile, it will be replaced. The change shall be persistent. Adding a VideoAnalyticsConfiguration to a media profile means that streams using that media profile can contain video analytics data (in the metadata) as defined by the submitted configuration reference. A profile containing only a video analytics configuration but no video source configuration is incomplete. Therefore, a client should first add a video source configuration to a profile before adding a video analytics configuration. The device can deny adding of a video analytics configuration before a video source configuration.
   * @param {string} profileToken Reference to the profile where the configuration should be added.
   * @param {string} configurationToken Contains a reference to the VideoAnalyticsConfiguration to add.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  addVideoAnalyticsConfiguration (profileToken, configurationToken, callback) {
    return this.addConfiguration('AddVideoAnalyticsConfiguration', profileToken, configurationToken, callback)
  }

  /**
   * This operation adds a Metadata configuration to an existing media profile. If a configuration exists in the media profile, it will be replaced. The change shall be persistent. Adding a MetadataConfiguration to a Profile means that streams using that profile contain metadata. Metadata can consist of events, PTZ status, and/or video analytics data.
   * @param {string} profileToken Reference to the profile where the configuration should be added.
   * @param {string} configurationToken Contains a reference to the MetadataConfiguration to add.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  addMetadataConfiguration (profileToken, configurationToken, callback) {
    return this.addConfiguration('AddMetadataConfiguration', profileToken, configurationToken, callback)
  }

  /**
   * This operation adds an AudioOutputConfiguration to an existing media profile. If a configuration exists in the media profile, it will be replaced. The change shall be persistent.
   * @param {string} profileToken Reference to the profile where the configuration should be added.
   * @param {string} configurationToken Contains a reference to the AudioOutputConfiguration to add.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  addAudioOutputConfiguration (profileToken, configurationToken, callback) {
    return this.addConfiguration('AddAudioOutputConfiguration', profileToken, configurationToken, callback)
  }

  /**
   * This operation adds an AudioDecoderConfiguration to an existing media profile. If a configuration exists in the media profile, it shall be replaced. The change shall be persistent.
   * @param {string} profileToken Reference to the profile where the configuration should be added.
   * @param {string} configurationToken This element contains a reference to the AudioDecoderConfiguration to add.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  addAudioDecoderConfiguration (profileToken, configurationToken, callback) {
    return this.addConfiguration('AddAudioDecoderConfiguration', profileToken, configurationToken, callback)
  }

  removeVideoSourceConfiguration () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  removeVideoEncoderConfiguration () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  removeAudioSourceConfiguration () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  removeAudioEncoderConfiguration () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  removePTZConfiguration () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  removeVideoAnalyticsConfiguration () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  removeMetadataConfiguration () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  removeAudioOutputConfiguration () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  removeAudioDecoderConfiguration () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  /**
   * This operation deletes a profile. This change shall always be persistent. Deletion of a profile is only possible for non-fixed profiles
   * @param {string} profileToken This attribute contains a reference to the profile that should be deleted.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  deleteProfile (profileToken, callback) {
    return this.requestWithProfileToken('DeleteProfile', profileToken, callback)
  }

  /**
   * This command lists all available physical video inputs of the device.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getVideoSources (callback) {
    return this.buildRequest('GetVideoSources', null, callback)
  }

  /**
   * This operation lists all existing video source configurations for a device. The client need not know anything about the video source configurations in order to use the command.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getVideoSourceConfigurations (callback) {
    return this.buildRequest('GetVideoSourceConfigurations', null, callback)
  }

  /**
   * If the video source configuration token is already known, the video source configuration can be fetched through the GetVideoSourceConfiguration command.
   * @param {string} configurationToken Token of the requested video source configuration.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getVideoSourceConfiguration (configurationToken, callback) {
    return this.requestWithConfigurationToken('GetVideoSourceConfiguration', configurationToken, callback)
  }

  /**
   * This operation requests all the video source configurations of the device that are compatible with a certain media profile. Each of the returned configurations shall be a valid input parameter for the AddVideoSourceConfiguration command on the media profile. The result will vary depending on the capabilities, configurations and settings in the device.
   * @param {string} profileToken Contains the token of an existing media profile the configurations shall be compatible with.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getCompatibleVideoSourceConfigurations (profileToken, callback) {
    return this.requestWithProfileToken('GetCompatibleVideoSourceConfigurations', profileToken, callback)
  }

  /**
   * This operation returns the available options (supported values and ranges for video source configuration parameters) when the video source parameters are reconfigured If a video source configuration is specified, the options shall concern that particular configuration. If a media profile is specified, the options shall be compatible with that media profile.
   * @param {string=} profileToken Optional ProfileToken that specifies an existing media profile that the options shall be compatible with.
   * @param {string=} configurationToken Optional video source configurationToken that specifies an existing configuration that the options are intended for.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getVideoSourceConfigurationOptions (profileToken, configurationToken, callback) {
    return this.requestWithOptionalTokens('GetVideoSourceConfigurationOptions', profileToken, configurationToken, callback)
  }

  setVideoSourceConfiguration () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  /**
   * This operation lists all existing video encoder configurations of a device. This command lists all configured video encoder configurations in a device. The client need not know anything apriori about the video encoder configurations in order to use the command.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getVideoEncoderConfigurations (callback) {
    return this.buildRequest('GetVideoEncoderConfigurations', null, callback)
  }

  /**
   * If the video encoder configuration token is already known, the encoder configuration can be fetched through the GetVideoEncoderConfiguration command.
   * @param {string} configurationToken Token of the requested video encoder configuration.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getVideoEncoderConfiguration (configurationToken, callback) {
    return this.requestWithConfigurationToken('GetVideoEncoderConfiguration', configurationToken, callback)
  }

  /**
   * This operation lists all the video encoder configurations of the device that are compatible with a certain media profile. Each of the returned configurations shall be a valid input parameter for the AddVideoEncoderConfiguration command on the media profile. The result will vary depending on the capabilities, configurations and settings in the device.
   * @param {string} profileToken Contains the token of an existing media profile the configurations shall be compatible with.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getCompatibleVideoEncoderConfigurations (profileToken, callback) {
    return this.requestWithProfileToken('GetCompatibleVideoEncoderConfigurations', profileToken, callback)
  }

  /**
   * This operation returns the available options (supported values and ranges for video encoder configuration parameters) when the video encoder parameters are reconfigured.&lt;br>
   * For JPEG, MPEG4 and H264 extension elements have been defined that provide additional information. A device must provide the XxxOption information for all encodings supported and should additionally provide the corresponding XxxOption2 information.&lt;br>
   * This response contains the available video encoder configuration options. If a video encoder configuration is specified, the options shall concern that particular configuration. If a media profile is specified, the options shall be compatible with that media profile. If no tokens are specified, the options shall be considered generic for the device.
   * @param {string=} profileToken Optional ProfileToken that specifies an existing media profile that the options shall be compatible with.
   * @param {string=} configurationToken Optional video encoder configuration token that specifies an existing configuration that the options are intended for.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getVideoEncoderConfigurationOptions (profileToken, configurationToken, callback) {
    return this.requestWithOptionalTokens('GetCompatibleVideoEncoderConfigurations', profileToken, configurationToken, callback)
  }

  setVideoEncoderConfiguration () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  /**
   * The GetGuaranteedNumberOfVideoEncoderInstances command can be used to request the minimum number of guaranteed video encoder instances (applications) per Video Source Configuration.
   * @param {string} configurationToken Token of the video source configuration
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getGuaranteedNumberOfVideoEncoderInstances (configurationToken, callback) {
    return this.requestWithConfigurationToken('GetGuaranteedNumberOfVideoEncoderInstances', configurationToken, callback)
  }

  /**
   * This command lists all available physical audio inputs of the device.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getAudioSources (callback) {
    return this.buildRequest('GetAudioSources', null, callback)
  }

  /**
   * This operation lists all existing audio source configurations of a device. This command lists all audio source configurations in a device. The client need not know anything apriori about the audio source configurations in order to use the command.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getAudioSourceConfigurations (callback) {
    return this.buildRequest('GetAudioSourceConfigurations', null, callback)
  }

  /**
   * The GetAudioSourceConfiguration command fetches the audio source configurations if the audio source configuration token is already known.
   * @param {string} configurationToken Token of the requested audio source configuration.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getAudioSourceConfiguration (configurationToken, callback) {
    return this.requestWithConfigurationToken('GetAudioSourceConfiguration', configurationToken, callback)
  }

  /**
   * This operation requests all audio source configurations of the device that are compatible with a certain media profile. Each of the returned configurations shall be a valid input parameter for the AddAudioEncoderConfiguration command on the media profile. The result varies depending on the capabilities, configurations and settings in the device.
   * @param {string} profileToken Contains the token of an existing media profile the configurations shall be compatible with.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getCompatibleAudioSourceConfigurations (profileToken, callback) {
    return this.requestWithProfileToken('GetCompatibleAudioSourceConfigurations', profileToken, callback)
  }

  /**
   * This operation returns the available options (supported values and ranges for audio source configuration parameters) when the audio source parameters are reconfigured. If an audio source configuration is specified, the options shall concern that particular configuration. If a media profile is specified, the options shall be compatible with that media profile.
   * @param {string=} profileToken Optional ProfileToken that specifies an existing media profile that the options shall be compatible with.
   * @param {string=} configurationToken Optional audio source configuration token that specifies an existing configuration that the options are intended for.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getAudioSourceConfigurationOptions (profileToken, configurationToken, callback) {
    return this.requestWithOptionalTokens('GetAudioSourceConfigurationOptions', profileToken, configurationToken, callback)
  }

  setAudioSourceConfiguration () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  /**
   * This operation lists all existing device audio encoder configurations. The client need not know anything apriori about the audio encoder configurations in order to use the command.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getAudioEncoderConfigurations (callback) {
    return this.buildRequest('GetAudioEncoderConfigurations', null, callback)
  }

  /**
   * The GetAudioEncoderConfiguration command fetches the encoder configuration if the audio encoder configuration token is known.
   * @param {string} configurationToken Token of the requested audio encoder configuration.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getAudioEncoderConfiguration (configurationToken, callback) {
    return this.requestWithConfigurationToken('GetAudioEncoderConfiguration', configurationToken, callback)
  }

  /**
   * This operation requests all audio encoder configurations of a device that are compatible with a certain media profile. Each of the returned configurations shall be a valid input parameter for the AddAudioSourceConfiguration command on the media profile. The result varies depending on the capabilities, configurations and settings in the device.
   * @param {string} profileToken Contains the token of an existing media profile the configurations shall be compatible with.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getCompatibleAudioEncoderConfigurations (profileToken, callback) {
    return this.requestWithProfileToken('GetCompatibleAudioEncoderConfigurations', profileToken, callback)
  }

  /**
   * This operation returns the available options (supported values and ranges for audio encoder configuration parameters) when the audio encoder parameters are reconfigured.
   * @param {string=} profileToken Optional ProfileToken that specifies an existing media profile that the options shall be compatible with.
   * @param {string=} configurationToken Optional audio encoder configuration token that specifies an existing configuration that the options are intended for.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getAudioEncoderConfigurationOptions (profileToken, configurationToken, callback) {
    return this.requestWithOptionalTokens('GetAudioEncoderConfigurationOptions', profileToken, configurationToken, callback)
  }

  setAudioEncoderConfiguration () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  /**
   * This operation lists all video analytics configurations of a device. This command lists all configured video analytics in a device. The client need not know anything apriori about the video analytics in order to use the command.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getVideoAnalyticsConfigurations (callback) {
    return this.buildRequest('GetVideoAnalyticsConfigurations', null, callback)
  }

  getVideoAnalyticsConfiguration () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  getCompatibleVideoAnalyticsConfigurations () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  setVideoAnalyticsConfiguration () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  /**
   * This operation lists all existing metadata configurations. The client need not know anything apriori about the metadata in order to use the command.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getMetadataConfigurations (callback) {
    return this.buildRequest('GetMetadataConfigurations', null, callback)
  }

  /**
   * The GetMetadataConfiguration command fetches the metadata configuration if the metadata token is known.
   * @param {string} configurationToken Token of the requested metadata configuration.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getMetadataConfiguration (configurationToken, callback) {
    return this.requestWithConfigurationToken('GetMetadataConfiguration', configurationToken, callback)
  }

  /**
   * This operation requests all the metadata configurations of the device that are compatible with a certain media profile. Each of the returned configurations shall be a valid input parameter for the AddMetadataConfiguration command on the media profile. The result varies depending on the capabilities, configurations and settings in the device.
   * @param {string} profileToken Contains the token of an existing media profile the configurations shall be compatible with.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getCompatibleMetadataConfigurations (profileToken, callback) {
    return this.requestWithProfileToken('GetCompatibleMetadataConfigurations', profileToken, callback)
  }

  /**
   * This operation returns the available options (supported values and ranges for metadata configuration parameters) for changing the metadata configuration.
   * @param {string=} profileToken Optional ProfileToken that specifies an existing media profile that the options shall be compatible with.
   * @param {string=} configurationToken Optional metadata configuration token that specifies an existing configuration that the options are intended for.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getMetadataConfigurationOptions (profileToken, configurationToken, callback) {
    return this.requestWithOptionalTokens('GetMetadataConfigurationOptions', profileToken, configurationToken, callback)
  }

  setMetadataConfiguration () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  /**
   * This operation lists all existing metadata configurations. The client need not know anything apriori about the metadata in order to use the command.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getAudioOutputs (callback) {
    return this.buildRequest('GetAudioOutputs', null, callback)
  }

  /**
   * This command lists all existing AudioOutputConfigurations of a device. The NVC need not know anything apriori about the audio configurations to use this command.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getAudioOutputConfigurations (callback) {
    return this.buildRequest('GetAudioOutputConfigurations', null, callback)
  }

  getAudioOutputConfiguration () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  getCompatibleAudioOutputConfigurations () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  getAudioOutputConfigurationOptions () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  setAudioOutputConfiguration () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  /**
   * This command lists all existing AudioDecoderConfigurations of a device. The NVC need not know anything apriori about the audio decoder configurations in order to use this command.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getAudioDecoderConfigurations (callback) {
    return this.buildRequest('GetAudioDecoderConfigurations', null, callback)
  }

  getAudioDecoderConfiguration () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  getCompatibleAudioDecoderConfigurations () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  getAudioDecoderConfigurationOptions () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  setAudioDecoderConfiguration () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  /**
   * This operation requests a URI that can be used to initiate a live media stream using RTSP as the control protocol. The returned URI shall remain valid indefinitely even if the profile is changed. The ValidUntilConnect, ValidUntilReboot and Timeout Parameter shall be set accordingly (ValidUntilConnect=false, ValidUntilReboot=false, timeout=PT0S).&lt;br>
   * The correct syntax for the StreamSetup element for these media stream setups defined in 5.1.1 of the streaming specification are as follows:&lt;br>
   * &lt;ul>
   * &lt;li>RTP unicast over UDP: StreamType = "RTP_unicast", TransportProtocol = "UDP"&lt;/li>
   * &lt;li>RTP over RTSP over HTTP over TCP: StreamType = "RTP_unicast", TransportProtocol = "HTTP"&lt;/li>
   * &lt;li>RTP over RTSP over TCP: StreamType = "RTP_unicast", TransportProtocol = "RTSP"&lt;/li>
   * &lt;/ul>
   * If a multicast stream is requested the VideoEncoderConfiguration, AudioEncoderConfiguration and MetadataConfiguration element inside the corresponding media profile must be configured with valid multicast settings.&lt;br>
   * For full compatibility with other ONVIF services a device should not generate Uris longer than 128 octets.
   * @param {RTP-Unicast|RTP-Multicast} streamType Defines if a multicast or unicast stream is requested.
   * @param {UDP|HTTP|RTSP} protocolType The transport protocol to use.
   * @param {string} profileToken The ProfileToken element indicates the media profile to use and will define the configuration of the content of the stream.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getStreamUri (streamType, protocolType, profileToken, callback) {
    let promise = new Promise((resolve, reject) => {
      let errMsg = ''
      if ((errMsg = Util.isInvalidValue(streamType, 'string'))) {
        reject(new Error('The "streamType" argument for getStreamUri is invalid: ' + errMsg))
        return
      }
      else if (!streamType.match(/^(RTP-Unicast|RTP-Multicast)$/)) {
        reject(new Error('The "streamType" argument for getStreamUri is invalid: The value must be either "UDP", "HTTP", or "RTSP".'))
        return
      }

      if ((errMsg = Util.isInvalidValue(protocolType, 'string'))) {
        reject(new Error('The "protocolType" argument for getStreamUri is invalid: ' + errMsg))
        return
      }
      else if (!protocolType.match(/^(UDP|HTTP|RTSP)$/)) {
        reject(new Error('The "protocolType" argument for getStreamUri is invalid: The value must be either "UDP", "HTTP", or "RTSP".'))
        return
      }

      if ((errMsg = Util.isInvalidValue(profileToken, 'string'))) {
        reject(new Error('The "profileToken" argument for getStreamUri is invalid: ' + errMsg))
        return
      }

      let soapBody = ''
      soapBody += '&lt;trt:StreamSetup>'
      soapBody += '&lt;tt:Stream>' + streamType + '&lt;/tt:Stream>'
      soapBody += '&lt;tt:Transport>'
      soapBody += '&lt;tt:Protocol>' + protocolType + '&lt;/tt:Protocol>'
      soapBody += '&lt;/tt:Transport>'
      soapBody += '&lt;/trt:StreamSetup>'
      soapBody += '&lt;trt:ProfileToken>' + profileToken + '&lt;/trt:ProfileToken>'

      this.buildRequest('GetStreamUri', soapBody)
        .then(results => {
          resolve(results)
        }).catch(error => {
          reject(error)
        })
    })
    if (callback) {
      promise.then(results => {
        callback(null, results)
      }).catch(error => {
        callback(error)
      })
    }
    else {
      return promise
    }
  }

  /**
   * A client uses the GetSnapshotUri command to obtain a JPEG snapshot from the device. The returned URI shall remain valid indefinitely even if the profile is changed. The ValidUntilConnect, ValidUntilReboot and Timeout Parameter shall be set accordingly (ValidUntilConnect=false, ValidUntilReboot=false, timeout=PT0S). The URI can be used for acquiring a JPEG image through a HTTP GET operation. The image encoding will always be JPEG regardless of the encoding setting in the media profile. The Jpeg settings (like resolution or quality) may be taken from the profile if suitable. The provided image will be updated automatically and independent from calls to GetSnapshotUri.
   * @param {string} profileToken The ProfileToken element indicates the media profile to use and will define the source and dimensions of the snapshot.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  getSnapshotUri (profileToken, callback) {
    return this.requestWithProfileToken('GetSnapshotUri', profileToken, callback)
  }

  /**
   * This command starts multicast streaming using a specified media profile of a device. Streaming continues until StopMulticastStreaming is called for the same Profile. The streaming shall continue after a reboot of the device until a StopMulticastStreaming request is received. The multicast address, port and TTL are configured in the VideoEncoderConfiguration, AudioEncoderConfiguration and MetadataConfiguration respectively.
   * @param {string} profileToken Contains the token of the Profile that is used to define the multicast stream.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  startMulticastStreaming (profileToken, callback) {
    return this.requestWithProfileToken('StartMulticastStreaming', profileToken, callback)
  }

  /**
   * This command stop multicast streaming using a specified media profile of a device.
   * @param {string} profileToken Contains the token of the Profile that is used to define the multicast stream.
   * @param {callback=} callback Optional callback, instead of a Promise.
   */
  stopMulticastStreaming (profileToken, callback) {
    return this.requestWithProfileToken('StopMulticastStreaming', profileToken, callback)
  }

  setSynchronizationPoint () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  getVideoSourceModes () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  setVideoSourceMode () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  createOSD () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  deleteOSD () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  getOSDs () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  getOSD () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  setOSD () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }

  getOSDOptions () {
    return new Promise((resolve, reject) => {
      reject(new Error('Not implemented'))
    })
  }
}

module.exports = new Media()
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Access.html">Access</a></li><li><a href="AccessRules.html">AccessRules</a></li><li><a href="Action.html">Action</a></li><li><a href="Analytics.html">Analytics</a></li><li><a href="Camera.html">Camera</a></li><li><a href="Core.html">Core</a></li><li><a href="Credential.html">Credential</a></li><li><a href="DeviceIO.html">DeviceIO</a></li><li><a href="Discovery.html">Discovery</a></li><li><a href="Display.html">Display</a></li><li><a href="Door.html">Door</a></li><li><a href="Events.html">Events</a></li><li><a href="Imaging.html">Imaging</a></li><li><a href="Media.html">Media</a></li><li><a href="Media2.html">Media2</a></li><li><a href="OnvifManager.html">OnvifManager</a></li><li><a href="Ptz.html">Ptz</a></li><li><a href="Receiver.html">Receiver</a></li><li><a href="Recording.html">Recording</a></li><li><a href="Replay.html">Replay</a></li><li><a href="Schedule.html">Schedule</a></li><li><a href="Search.html">Search</a></li><li><a href="Security.html">Security</a></li><li><a href="Soap.html">Soap</a></li><li><a href="Thermal.html">Thermal</a></li><li><a href="VideoAnalytics.html">VideoAnalytics</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sat Feb 17 2018 09:55:53 GMT-0700 (MST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
